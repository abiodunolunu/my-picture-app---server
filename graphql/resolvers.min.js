const{default:validator}=require("validator"),User=require("../models/User"),bcrypt=require("bcryptjs"),jwt=require("jsonwebtoken"),{jwtSecret:jwtSecret}=require("../config"),Post=require("../models/Post"),Comment=require("../models/Comment");module.exports={createUser:async({userInput:userInput},req)=>{const{firstname:firstname,lastname:lastname,email:email,password:password,confirmPassword:confirmPassword}=userInput,errors=[];if(validator.isEmail(userInput.email)||errors.push({message:"E-mail is invalid"}),!validator.isEmpty(userInput.password)&&validator.isLength(userInput.password,{min:5})||errors.push({message:"Password is too short"}),errors.length>0){const error=new Error("Invalid Input");throw error.data=errors,error.code=422,error}try{const existingUser=await User.findOne({email:email});if(existingUser){errors.push({message:"Email already exists, use another one"});const error=new Error("User exists allready");throw error}const hashedPassword=await bcrypt.hash(password,12),user=new User({firstname:firstname,lastname:lastname,email:email,password:hashedPassword}),createdUser=await user.save();return{...createdUser._doc,id:createdUser._id.toString()}}catch(err){const error=new Error(err);throw error.data=errors,error.code=422,error}},login:async({email:email,password:password},req)=>{const errors=[];if(validator.isEmail(email)||errors.push({message:"Please enter a valid email"}),errors.length>0){const error=new Error("Invalid Input");throw error.data=errors,error.code=422,error}try{const user=await User.findOne({email:email});if(!user){errors.push({message:"No user found with that email"});const error=new Error("No user found");throw error}const isEqual=await bcrypt.compare(password,user.password);if(!isEqual){errors.push({message:"password is incorrect"});const error=new Error("Wrong Password");throw error}const token=jwt.sign({userId:user._id.toString(),email:user.email},jwtSecret,{expiresIn:"1h"});return console.log(user._id.toString()),{token:token,user:{...user._doc,id:user._id.toString()}}}catch(err){const error=new Error(err);throw error.data=errors,error.code=401,error}},createPost:async({imageUrl:imageUrl,caption:caption},req)=>{if(!imageUrl){const error=new Error("Image Required");throw error.code=422,error}const post=new Post({owner:req.userId,imageUrl:imageUrl,caption:caption}),createdPost=await post.save();return{...createdPost._doc,id:createdPost._id.toString(),createdAt:createdPost.createdAt.toString(),updatedAt:createdPost.updatedAt.toString()}},getPosts:async req=>{const ALLPOSTS=[],posts=await Post.find().cursor(),comments=await posts.eachAsync((async function(doc){const comment=await Comment.findOne().where("post").equals(doc._id).populate("author","-password"),post={...doc._doc};post.latestComment=comment,ALLPOSTS.push(post)}));return{posts:ALLPOSTS.map(post=>({...post,_id:post._id.toString(),createdAt:post.createdAt.toISOString(),updatedAt:post.updatedAt.toISOString()}))}},createComment:async({postId:postId,text:text,author:author},req)=>{const comment=new Comment({post:postId,author:author,text:text}),savedComment=await(await comment.save()).populate("author").populate("post").execPopulate();return console.log(savedComment),{text:savedComment.text,author:{...savedComment.author._doc,_id:savedComment.author._id.toString()},post:{...savedComment.post._doc,_id:savedComment.post._id.toString()}}}};